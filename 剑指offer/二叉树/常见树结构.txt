参考：《数据结构与》

0. 完全树：
高度: h = log(n+1)向上取整  (n为节点总数)
设根节点下标i(从1开始),则左子节点下标为2i,右子节点下标为2i+1;
设根节点下标i(从0开始),则左子节点下标为2i+1,右子节点下标为2i+2.


1、二叉搜索树：
左子节点总是<=根节点<=右子节点，或者空树。
又名：二叉查找树，二叉排序树。
时间复杂度：可以在logn的时间根据数值找到某个节点。

2、堆：
条件1：堆中某个节点的值总是不大于或不小于其父节点的值；
条件2：堆总是一棵完全二叉树。（编号与满二叉树一一对应的树叫完全二叉树。）
最大堆：根节点最大、完全二叉树。
最小堆：根节点最小、完全二叉树。
快速找到最大值和最小值，常通过堆实现。
堆的常见实现是使用数组。

3、平衡二叉树：
左右子树的高度差的绝对值不超过1，并且两个子树都是平衡二叉树。或者空树。
AVL-tree, RB-tree, AA-tree都是平衡二叉树。
最小平衡二叉树的节点总数：F(n)=F(n-1)+F(n-2)+1，1是根节点，F(n-1)是左子树节点数，F(n-2)是右子树节点数。
平衡因子：左子树的高度-右子树的高度

4、红黑树：
把节点分为红、黑色，并通过规则保证从根节点到叶节点的最长路径<=最短路径的2倍。
又名：自平衡二叉搜索树、对称二叉B树、AVL-树（AVL是两个发明者名字）。
定义：首先是二叉搜索树，
（1）每个节点不是红色就是黑色；
（2）根节点为黑色；
（3）如果节点为红，其子节点必须为黑；
（4）任一子节点至NULL（树尾端）的任何路径，所含黑节点数必须相同。
根据（4），新增节点必须为红，否则就有一条路径的黑节点数多一个；
根据（3），新增节点的父节点必须为黑。
时间复杂度：可以在logn时间内查找、插入、删除（n为节点数）。在最坏情况下运行时间依然良好。
红黑树的平衡性比AVL-tree弱。但是红黑树通常能够导致良好的平衡状态，经验表明，RB-tree的搜寻平均效率和AVL-tree几乎相等。

红黑树定义2：
满足以下性质的拥有两条链（红链和黑链）的二叉查找树：
（1）从根到每个叶子节点的路径都包含相同数目的黑链；
（2）从根到每个叶子节点的路径不能包含两个或更多的连续红链。

旋转：
（1）寻找插入位置（记录父亲、祖父、曾祖父节点）；
（2）插入时，新增链初始化为红链；
（2）只要在查找路径上碰到4-节点（即有两个孩子）q，把q指向两个孩子的链改成黑色；把来自父亲的链改成红色；
（3）如果存在两条连续的红链，执行AVL旋转。

5、AVL-树：
左右子树的高度差的绝对值不超过1，并且两个子树都是平衡二叉树。或者空树。

B树（m阶）：一般用于查找外存数据。
（1）每个节点最多放m-1个数据值；
（2）每个非叶子节点（根节点除外）为k节点，其中(m+1)/2<=k<=m）
（3）所有叶子节点处于同一层。
m阶，指的是有m个指针，但是只有m-1个数据。
B树的一个节点往往存储着一个文件块，这是每次存取能够获得的最大信息量。
实验数据表明，当m处于50~400之间时，性能最好。

2-3-4树是4阶B树：
（1）每个节点最多有3个数据值；
（2）每个非叶子节点要么是2-节点，要么是3-节点，要么是4-节点；
（3）所有叶子处于同一层。

6、跳跃表



