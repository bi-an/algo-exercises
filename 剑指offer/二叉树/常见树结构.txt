参考：《数据结构与抽象：Java语言描述（原书第4版）》 2017.5 
	Frank M. Carrano 罗德岛大学, Timothy M. Henry 新英格兰理工学院 著
	辛运帷 饶一梅 译 北京：机械工业出版社

0. 完全树：
高度: h = log(n+1)向上取整  (n为节点总数)
设根节点下标i(从1开始),则左子节点下标为2i,右子节点下标为2i+1;
设根节点下标i(从0开始),则左子节点下标为2i+1,右子节点下标为2i+2.


1、二叉搜索树：
左子节点总是<=根节点<=右子节点，或者空树。
又名：二叉查找树，二叉排序树。
时间复杂度：可以在logn的时间根据数值找到某个节点。

2、堆：
条件1：堆中某个节点的值总是不大于或不小于其父节点的值；
条件2：堆总是一棵完全二叉树。（编号与满二叉树一一对应的树叫完全二叉树。）
最大堆：根节点最大、完全二叉树。
最小堆：根节点最小、完全二叉树。
快速找到最大值和最小值，常通过堆实现。
堆的常见实现是使用数组。

3、平衡二叉树：
左右子树的高度差的绝对值不超过1，并且两个子树都是平衡二叉树。或者空树。
AVL-tree, RB-tree, AA-tree都是平衡二叉树。
最小平衡二叉树的节点总数：F(n)=F(n-1)+F(n-2)+1，1是根节点，F(n-1)是左子树节点数，F(n-2)是右子树节点数。
平衡因子：左子树的高度-右子树的高度

4、红黑树：
把节点分为红、黑色，并通过规则保证从根节点到叶节点的最长路径<=最短路径的2倍。
又名：自平衡二叉搜索树、对称二叉B树、AVL-树（AVL是两个发明者名字）。
定义：首先是二叉搜索树，
（1）每个节点不是红色就是黑色；
（2）根节点为黑色；
（3）如果节点为红，其子节点必须为黑；
（4）任一子节点至NULL（树尾端）的任何路径，所含黑节点数必须相同。
根据（4），新增节点必须为红，否则就有一条路径的黑节点数多一个；
根据（3），新增节点的父节点必须为黑。
时间复杂度：可以在logn时间内查找、插入、删除（n为节点数）。在最坏情况下运行时间依然良好。
红黑树的平衡性比AVL-tree弱。但是红黑树通常能够导致良好的平衡状态，经验表明，RB-tree的搜寻平均效率和AVL-tree几乎相等。

红黑树定义2：
满足以下性质的拥有两条链（红链和黑链）的二叉查找树：
（1）从根到每个叶子节点的路径都包含相同数目的黑链；
（2）从根到每个叶子节点的路径不能包含两个或更多的连续红链。

旋转：
（1）寻找插入位置（记录父亲、祖父、曾祖父节点）；
（2）插入时，新增链初始化为红链；
（2）只要在查找路径上碰到4-节点（即有两个孩子）q，把q指向两个孩子的链改成黑色；把来自父亲的链改成红色；
（3）如果存在两条连续的红链，执行AVL旋转。

红黑树最差情况（最不平衡的情况），查找复杂度是2logn

5、AVL-树：
左右子树的高度差的绝对值不超过1，并且两个子树都是平衡二叉树。或者空树。

AVL与红黑树比较：
https://www.jianshu.com/p/37436ed14cc6
删除节点导致失衡：AVL需要维护从被删除节点到根节点root这条路径上所有节点的平衡，旋转的量级为O(logN)，
而RB-Tree最多只需要旋转3次实现复衡，只需O(1)，所以说RB-Tree删除节点的rebalance的效率更高，开销更小！

B树（m阶）：一般用于查找外存数据。
（1）每个节点最多放m-1个数据值；
（2）每个非叶子节点（根节点除外）为k节点，其中(m+1)/2<=k<=m）
（3）所有叶子节点处于同一层。
（4）每个节点内部，按照key排序。
m阶，指的是有m个指针，但是只有m-1个数据。
B树的一个节点往往存储着一个文件块，这是每次存取能够获得的最大信息量。
实验数据表明，当m处于50~400之间时，性能最好。

B+树（m阶）：
与B-树定义基本相同，除了：
（1）B+树只有叶子节点会带有指向记录的指针，而B树则所有节点都带有；
（2）每个叶子节点含有一个指针，指向其兄弟（最后一个叶子的指针为nullptr）。

B+树优于B-树：
（1）因为B+内部节点不存储数据，这样可以使得它的出度更大（对于同样的IO存储大小而言），所以高度更小，所以检索速度更快。
（2）又由于每个叶子还有一个指向兄弟的指针，所以区间查询更快；
（3）所有数据都在叶子上，所以查询稳定，都等于O(h)。

2-3-4树是4阶B树：
（1）每个节点最多有3个数据值；
（2）每个非叶子节点要么是2-节点，要么是3-节点，要么是4-节点；
（3）所有叶子处于同一层。

6、跳跃表



