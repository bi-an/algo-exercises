0. 完全树：
高度: h = log(n+1)向上取整  (n为节点总数)
设根节点下标i(从1开始),则左子节点下标为2i,右子节点下标为2i+1;
设根节点下标i(从0开始),则左子节点下标为2i+1,右子节点下标为2i+2.

若节点下标从1开始，那么第L层（从1开始）第一个下标和该层节点数均为2^(L-1)。
这是因为：(第L层的第一个下标) = (第L-1层第一个下标) + (第L-1层节点个数)，第L层节点个数 = 2 * （第L-1层节点个数），
而第1层第一个下标和节点个数均为1（2^0），又因为性质：2^n + 2^n = 2^(n+1)，这样每层第一个下标恰好和该层节点个数相等。

最大堆：完全二叉树，且根节点大于或等于后代。
“半堆”：替换掉堆顶之后的堆，即：左右子树都是堆。

当二叉数是完全二叉树时，可用数组表示。

reheap()
将半堆转换成堆：比较下沉
时间复杂度: O(logn)
分析：最坏情况下，reheap从根到叶子节点的路径执行，这条路径上的节点数为树高h,所以reheap是O(h)的；
含n个节点的树的高度h=log(n+1)向上取整，所以reheap方法是O(logn)的。

堆建立：O(n)   
	推导：要对除了最下一层的所有节点为根的子树reheap，对于第L层的某个节点，他的子树的高度是h-L+1, 第L层最多有2^(L-1)个节点；
	所以复杂度是 O(sum((h-L+1)*2^(L-1)))=O(2^h)=O(n).
插入：O(h)=O(logn)
	在最后插入，节点上浮：因为根节点一定比子节点大，所以，不断上浮并交换就可以，不需反复reheap.
删除：O(h)=O(logn)
	删除一定是删堆顶，删完之后将最后一个数放到堆顶，然后不断比较并下沉（即reheap）。
