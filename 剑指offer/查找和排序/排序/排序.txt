定理1：N个互异元素的数组的平均逆序数为N(N-1)/4.
定理2：通过交换相邻元素进行排序的任何算法平均时间为O(N^2).

1、选择排序
1.1、简单选择排序
比较O(n^2), 交换O(n).
不依赖原始排列，任何时候都是O(n^2).
不稳定。由于选出最小值后需要交换位置,位置一变就会变得不稳定.例如8  3  8  1.当从左往右遍历找最小值时,找到了1,这就需要把8跟1交换.这样两个相等元素8的位置就变了.

1.2、堆排序
不稳定。交换最大值的位置会导致不稳定.例如有大堆 8 8 6 5 2.先选出第一个最大值8,放最末尾.此时就不稳定了.因为第二个8就跑它前面去了.

3、基数排序
稳定。


4、桶排序(不稳定)

4、冒泡
稳定。是通过不停的遍历,以升序为例,如果相邻元素中左边的大于右边的则交换.碰到相等的时就不交换保持原位.所以是稳定的.当然如果你非得吃饱了撑着了,在碰到相等的时也交换下,那肯定变成不稳定的算法了.

5、快速排序
不稳定的。举例8   5   6  6 .以8为基准,由后向前遍历。第一趟交换后最后一个6跑到第一位,8到最后.第二趟交换.这个6跑到5的位置.变成有序的了.两个6位置变了,所以是不稳定的.

插入排序：
6、直接插入(稳定)
最优O(n), 最坏O(n^2), 原本排列越有序,所要做的工作越少。insertSort()调用insertInorder()次数为n-1，而insertInorder()内的循环最坏情况为1+2+...+(n-1)；对于有序数组，调用insertInorder立即退出。
直接插入时是先在已排序好的的子序列中找到合适的位置再插入.假设左边是已排序的,右边是没排序的.通过从后向前遍历已排序序列,然后插入,此时相等元素依然可以保持原有位置.
但是如果你从前向后遍历已排序序列就会是不稳定排序了.
可以对链式节点插入排序。效率是O(n^2).


,二分插入排序(不稳定)

希尔排序(不稳定)
希尔排序：针对插入排序的特点(越有序的数组，效率越高)，建议下表间隔由n/2开始，每次折半，最后一次间隔为1(即最后一次对所有数字插入排序).
使用三层循环，但是最坏为O(n^2)，而不是O(n^3)；改进：当space为偶数时，对space加1，这样最坏为O(n^1.5)

归并排序：
最优、最坏、平均O(nlogn)

