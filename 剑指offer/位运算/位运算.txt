1、为什么补码的补码，等于原码？

负数的补码：原码（带符号位），取反（除符号位外），加1
（或者：正数对应的二进制数，取反，加1）
则：负数的补码的补码：减1，取反（除符号位外），得到原码

减1取反：
若最后一位为1，则减去1，不影响其他位；这样，“减1取反”，与“取反加1”效果是一样的。

若最后一位为0，以100,100为例，
(1)、若减1取反：
100,100减去1后变成100,011，可以看到，减去1后，会将从右到左遇到的第一个1变成0，中途遇到的0全部变成1（从最右边的第一个1开始（包括这个1）的所有位取反）；然后再取反，会将减1所影响的位（黑体，即从右至左到第一个1的位）全部变回来，黑体位全部变回来；然后，再将其他位取反。

(2)取反加1：
 a. 非黑体位是一样的：100,100，因为取反会将从右至左的第一个1变成0，所以依然只会有黑体位的差别。
 b. 黑体位：
若取反加1：
100取反后，变成011，若加1，会将其变回为原来的100。

综上所述，取反加1，与减1取反是一样的。
并且，可以总结：从右至左到遇到第一个1为止（包括这个1）的所有位，“取反加1”或者“减1取反”，都不会被改变。

补充：补码可以将减法变成加法：以补12（钟表）为例，12-4=8，即12-4等价12（即0）+8.

2、（剑指Offer）面试题10：二进制中1的个数

题目：
输入一个整数，输出该数二进制表示中1的个数。其中负数用补码表示。
思路：
很明显，这道题考察的是位运算。
(1)、依次将整数右移，判断整数最后一位是否为1(&1)；
问题：如果该整数为负数，则会陷入无限循环，为什么？因为负数右移的时候，左边补1，整数右移过程中不可能为0，因此会陷入无限循环。
补码的移位：
左移，无论正数负数都在右边补0；
右移，正数在左边补0，负数在左边补1；

int NumberOf1(int n){
    int count=0;
    while(n){
        if(n&1)
            count++;
        n=n>>1;
    }
    return count;
}
(2)、依次将1左移i位，然后跟该整数做与&操作，如果结果不为0，则第i位为1；
问题：整数有多少位，就得循环多少次。
(3)、利用小技巧：
x&(x-1)可以将整数最右边的1变成0，例如x=100,100， x-1=100,011，可以看到，x-1相当于将右数到第一个1为止的所有位取反。
通过这个小技巧，我们只要循环判断n=n&(n-1)是否为0，即可统计1的个数。
整数中有多少个1，则循环多少次。

3、位运算相关题目：
(1)用一条语句判断一个整数是不是2的整数次方。


if(n&(n-1)==0) return true;

(2)输入两个整数m,n,计算需要改变m的二进制表示中的多少位才能得到n？


int x=m^n; return NumberOf1(x);　　

(3)找出一个数的第一个非0比特位(从右至左)


//int n != 0;
f_bit = n & ((n - 1)^-1);
f_bit = n & (~(n - 1))

一步一步看看

0011 0110     | 设n
0011 0101     | n - 1  把n的第一位置零
1111 1111     | - 1
1100 1010     | ^ -1  按位取反，将n的第一个非零比特位保留，其他位取反
0000 0010     | & n  除了第一个比特位，其他位都是相反的，相与得到第一个比特位
---------------------
原文：https://blog.csdn.net/mzx1317557721/article/details/70495637


int的表示范围：
-2^31 ~ 2^31-1
注意计算机的二进制表示是补码：
max=0x7FFFFFFF
min=0x80000000 
-1 =0xffffffff






