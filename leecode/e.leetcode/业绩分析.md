# 题目

某部门将近期每天的销售业绩按时间先后顺序存储在数组 `sales` 中，主管进行业绩分析时，希望找出经历业绩先**回落**后**上升**的任意三天，即要找出符合 `i < j <k` 且 `sales[j] < sales[k]` 条件下的下标组合方案。

请返回存在多少种符合条件的下标组合方案。

**注意：**答案需要取模 `1e9 + 7 (1000000007)` ，如计算初始结果为 `1000000008` ，请返回 `1` 。

**示例1：**

> 输入： `sales = [4,1,3,2,5]`
>
> 输出： `6`

> 解释：
>
> 有 6 种符合条件的下标组合方案：
>
> (0,1,2)，对应销售业绩为 [4,1,3]
>
> (0,1,3)，对应销售业绩为 [4,1,2]
>
> (0,1,4)，对应销售业绩为 [4,1,5]
>
> (0,2,4)，对应销售业绩为 [4,3,5]
>
> (0,3,4)，对应销售业绩为 [4,2,5]
>
> (2,3,4)，对应销售业绩为 [3,2,5]

**示例2：**

> 输入： `sales = [1,2,3,4]`
>
> 输出： `0`

**提示：**

- `1 <= sales.length <= 10^5`
- `1 <= sales[i] <= 10^6`

# 分析

要求 “先**回落**后**上升**”的序列数。

N = MAX_SALE = 1000000;

sales[i] 取值范围为 [1, MAX_VALUE]，建立一个 hashtable ，按序遍历 sales ，key为 sales[i] 的所有取值，value为 当前 sales[i] 出现的次数。

| i     | 1    | 2    | 3    | 4    | 5    |
| ----- | ---- | ---- | ---- | ---- | ---- |
| sales | 4    | 1    | 3    | 2    | 5    |

|      | x              | 1    | 2    | ...  | N-6  | N-5  | N-4  | N-3   | N-2   | N-1   | N    |
| ---- | -------------- | ---- | ---- | ---- | ---- | ---- | ---- | ----- | ----- | ----- | ---- |
|      | sales[i]的值域 | N    | N-1  | ...  | 7    | 6    | 5    | 4     | 3     | 2     | 1    |
| i=1  | hashtable[x]   | 0    | 0    | ...  | 0    | 0    | 0    | 0 → 1 | 0     | 0     | 0    |
| i=2  | hashtable[x]   | 0    | 0    | ...  | 0    | 0    | 0    | 1     | 0     | 0 → 1 | 0    |
| i=3  | hashtable[x]   | 0    | 0    | ...  | 0    | 0    | 0    | 1     | 0 → 1 | 1     | 0    |

遍历到 i 时，可以看出 hashtable 的前缀和恰好能够表示 sales 序列中左边比当前 sales[i] 大的数的个数。

如果暴力求解的话，每次遍历，计算当前前缀和时间为 O(N)，总时间则为 O(MN) ，其中 M 是sales.length 。我们希望能够迅速找出 hashtable 的前缀和，而**树状数组**可以在 logN 时间找出前缀和。


# 答案

```cpp
#include <iostream>
using namespace std;

const int MAX_VALUE = 1000000;
int n,m;
int tree[MAX_VALUE+1];

int lowbit(x) {
    return x & -x;
}

int main() {
    
}
```

