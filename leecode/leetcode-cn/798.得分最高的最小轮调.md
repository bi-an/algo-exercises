# 直接法

**思路：**轮调长度从 0 到 n-1 进行 n 次计算，每次计算分数，取最高分数时对应的轮调长度。

**时间复杂度：**每次计算分数，需要逐个比较 $i-nums[i] ≥ 0$ 是否满足，时间为 $O(n)$。轮调次数为 $n$。总时间为 $O(n^2)$。

# 优化思路

1. 为了找出最大的分数，我们需要遍历轮调长度从 0 ~ (n - 1) 的所有可能情况，这个时间是 O(n) ，不可避免。

2. 但是，我们发现，当次轮调可以看做上次轮调的重复，所以可能可以利用上一次的结果。

3. 为了简便，记 d = i - nums[i] ，那么可以认为 d >= 0 的位置可以得分。

4. 当次轮调相当于把上一次轮调结果中，把 d[0] 加上 n ，并且 d[0, 2, ..., n-1] 都减 1 ，然后通过判定 d‘ >= 0 来记分，其中 d' 表示操作后的 d 。

   - d - 1 >= 0 ，移项， d >= 1，也就是说，如果我们不进行所有数减 1 ，只需要不断增加判别阈值 threshold 即可。
   - 设轮调长度为 k
     - k = 0，d >= 0，即 threshold = 0
     - k = 1，d >= 1，即 threshold = 1
     - ....
     - k = k，d >= k，即 threshold = k
     
     即第 k 次轮调时的阈值恰好为 k.

   于是，我们不需要对 d 数组所有数进行操作，而是只操作一个数 d[0]。也就是 

   > d[0] = d[0] + n
   >
   > d[i] 不变，当 i ≠ 0
   >
   > 如果 d >= k ，则得分

5. 但是，我们还要将上一次的 d 数组进行移位，也就是把首位移动到末尾。这个时间是 O(n)。

   如果我们定义一个环形指针来遍历数组，记 start 指向数组的第一个位置，那么，数组第 i 个位置的实际下标值 j = (i - start + n) % n. 显然，第 k 次轮调时，start = k，于是从 k - 1 的快照求第 k 次的  d 数组的步骤又可以转化为

   >start = k
   >
   >d[start] = d[start] + n
   >
   >d[i] 不变，当 i ≠ start
   >
   >如果 d >= k ，则得分

   通过上述简化，我们将 d 数组的操作优化为 O(1)。

6. 但是为了得出当次的分数，我们还是需要逐个比较 d[i] >= k，时间还是 O(n)。

   实际上，d 数组中只有轮调前后穿越了判定阈值的元素会引起分数变化。

   具体地，

   - 如果第 k 次轮调时恰好等于判定阈值 k（则得分），而第 k + 1 次轮调（start = k + 1）时保持不变的那些 d （对应于 i ≠ start），阈值却上升为 k + 1，所以这些元素将不得分，所以此时分数应该减去这些元素的得分数（即这些元素的个数），即

     > score -= count(d == k)

   - 第 k + 1 轮调开始时，start = k + 1，d[start] 将发生突变，因为 d[start] = d[start] + n，如果变化之前 d[start] < k，也就是在第 k 次没有得分，而变化之后 d[start] + n >= k + 1，那么分数将增加 1，即

     > if d[start] < k and d[start] + n >= k + 1
     >
     > then score++

     细节：count(d == k) 应该放在 d[start] += n 之后计算。

7. 从第 6 点可以看出，如果我们提前统计出 d[i] == k 的个数，则可以将分数一步到位求出来，而不需要遍历整个 d 数组。于是想到哈希表。

   - 细节1：既然我们已经使用哈希表记录了 d 的每个可能值的个数，那么 d 的值也就已经保存下来，不需要额外建立 d 的数组。

   - 细节2：我们来看看哈希表的 key 的取值范围，也就是 d 的取值范围。

     由题意，0 <= nums[i] <= n - 1，

     初始时，-(n-1) <= d = i - nums[i] <= n - 1；

     之后迭代时，d 要么不变，要么 d += n，每个 d 只可能变化一次，也就是 start 指向其的时候。迭代次数为轮调长度的可能取值 [0, n-1]，于是，d 的最大值可能为 2n - 1.

     d 只可能变化一次，但是这一次变化，将引起 d 的值的计数，也就是影响哈希表。

     注意到，判定阈值 threshold = k 的范围为 [0, n - 1]，而 score -= count(d == k)，也就是只有在 [0, n - 1] 范围内的 d 会对分数造成影响。

     - 如果初始时 d < 0，计算分数时不需要统计；但是变化之后，d + n 恰好能落在 [0, n - 1] 区间。换言之，d < 0 的值只被用了 1 次，可以在使用时单独计算一次，不需要存入哈希表。
     
     - 如果初始时 d >= 0（当然初始时，d <= n - 1 必然成立），变化之后 d + n 必然大于 n - 1，超出了阈值的区间 [0, n - 1]，之后将保持不变，所以这个 d 的值不会再影响分数，没有用处了，也不需要存入哈希表。
     
       综上，哈希表中始终只需要存储 d ∈ [0, n - 1] 的计数。

