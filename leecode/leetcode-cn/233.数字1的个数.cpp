/*
 * @Author: your name
 * @Date: 2021-08-13 23:46:22
 * @LastEditTime: 2021-08-13 23:47:47
 * @LastEditors: Please set LastEditors
 * @Description: In User Settings Edit
 * @FilePath: \practice\leecode\leetcode-cn\233.数字1的个数.cc
 */

 
/**
 * 参考评论@龅牙叔 
https://leetcode-cn.com/problems/number-of-digit-one/solution/shu-zi-1-de-ge-shu-by-leetcode-solution-zopq/

这道题看了K神@Krahets的剑指题解才算弄明白, 我把题解再解释一下:

举个例子： n = 2304 。答案为四个部分之和：

1. 所有小于等于2304的正整数中，个位出现1的次数.
2. 所有小于等于2304的正整数中，十位出现1的次数.
3. 所有小于等于2304的正整数中，百位出现1的次数.
4. 所有小于等于2304的正整数中，千位出现1的次数.
这四部分可以只考虑一部分，另外三部分就异曲同工了。用第二部分来举例，也就是计算所有小于等于2304的正整数中，十位出现1的次数：

为了帮助理解，我们先想象有一个自行车密码锁（这个比喻来自@ryan0414），一共有四位，每一位可单独滚动。为了计算十位出现1的次数，我们考虑三种情况：

1. n中的十位为0. 即 n = 2304。
我们先锁住十位，强行让十位变成1，剩下三位可以随意滚动：XX1X。那么求十位出现一的个数也就是，我可以滚出多少种密码组合，使得该密码小于等于n（注意十位被锁定成了1，转不动）。

不难发现，我们能滚出的最大数是：2219,

我们能滚出的最小数是：0010。

那么0010到2219之间有多少种十位为1的密码呢？我们去掉十位，得到000和229。一共就是229-000+1 = 230种。即n千位和百位构成的数。

2. n中的十位为1. 即 n = 2314。
我们先锁住十位，强行让十位变成1，剩下三位可以随意滚动：XX1X。那么求十位出现一的个数也就是，我可以滚出多少种密码组合，使得该密码小于等于n（注意十位被锁定成了1，转不动）。

不难发现，我们能滚出的最大数是：2314,

我们能滚出的最小数是：0010。

那么0010到2314之间有多少种十位为1的密码呢？我们去掉十位，得到000和234，一共就是23*10+4+1 = 235种。即n千位和百位构成的数*10 + n个位的数字+1.

3. n中的十位为2~9中任意数字. 即 n = 2324（只是一个例子，n = 2394是一样的）。
我们先锁住十位，强行让十位变成1，剩下三位可以随意滚动：XX1X。那么求十位出现一的个数也就是，我可以滚出多少种密码组合，使得该密码小于等于n（注意十位被锁定成了1，转不动）。

不难发现，我们能滚出的最大数是：2319,

我们能滚出的最小数是：0010。

那么0010到2319之间有多少种十位为1的密码呢？我们去掉十位，得到000和239，一共就是（23+1）*10 = 240种。即(n万位和千位构成的数*+1)*10.

如果我们定义十位左边的数为高位，2304的高位为23，十位右边的数为低位，2304的低位为4，那么以上规律就可以写成高位和低位的规律。我们分别对2304的每一位做一次分析，并将四部分结果相加就得到了答案。
 * 
 */
class Solution {
public:
    int countDigitOne(int n) {
        // mulk表示10^k，这里使用long long是为了在接下来的乘法中，避免数字溢出
        // 因为mulk是其中主要因子，所以仅仅把mulk设置为long long就足够了
        long long mulk = 1;
        // 分别表示高位、低位、当前位
        int high, low, cur, ans = 0;

        while (n >= mulk) {
            low = n % mulk;
            high = n / mulk / 10;
            cur = n / mulk % 10;
            if (cur == 0) {
                ans += high * mulk;
            }
            else if (cur == 1) {
                ans += high* mulk + low + 1;
            }
            else {
                ans += (high + 1)*mulk;
            }
            mulk *= 10;
        }
        
        return ans;
    }
};