书籍：《C++并发编程实战》
作者：[美] Anthony Williams 著
	  周全，梁娟娟，宋真真，许敏 译

1. 锁粒度：
如果锁的粒度太小，那么起不到保护作用；如果粒度太大，基本变成串行，那多线程还不如单线程的性能。
解决：修改接口。减少接口，以扩大锁粒度。

2. 异常：
复制异常：例如，函数返回值是值类型，那么就会调用复制构造函数，如果值所含数据量过大，例如含有很多元素的vector，那么就会抛出std::bad_alloc异常，但是对象内的数据在return语句执行之前已经删除了（例如stack<vector<int>>）。
解决1：指针/shared_ptr返回，或者以引用传递。因为指针和引用基本没有内存开销，可以随便复制。
解决2：要求不引发异常的复制/移动构造函数。
可以同时使用上面多种解决方案，提高系统灵活性。