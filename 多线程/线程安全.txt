书籍：《C++并发编程实战》
作者：[美] Anthony Williams 著
	  周全，梁娟娟，宋真真，许敏 译

1. 锁粒度：
如果锁的粒度太小，那么起不到保护作用；如果粒度太大，基本变成串行，那多线程还不如单线程的性能。
解决：修改接口。减少接口，以扩大锁粒度。

2. 异常：
复制异常：例如，函数返回值是值类型，那么就会调用复制构造函数，如果值所含数据量过大，例如含有很多元素的vector，那么就会抛出std::bad_alloc异常，但是对象内的数据在return语句执行之前已经删除了（例如stack<vector<int>>）。
解决1：指针/shared_ptr返回，或者以引用传递。因为指针和引用基本没有内存开销，可以随便复制。--> 对于受保护的共享数据，不得传入引用。
解决2：要求不引发异常的复制/移动构造函数。
可以同时使用上面多种解决方案，提高系统灵活性。

3. 死锁：
原因1：每个线程都持有一个互斥元，而又在等待另一个线程所持有的互斥元。
FIX 1: 始终以相同的顺序锁定这两个互斥元。如果你总是在互斥元B之前锁定互斥元A，那么结果是要么同时获得A和B，要么都无法获得，这样永远不可能死锁。
问题：对于一个类(含有一个互斥元)的两个实例A和B，例如要交换他们的数据时，为了防止并发的问题，需要锁定他们的互斥元。但是如果按照"总是先锁A再锁B"的原则，反而会造成死锁。例如线程1锁定A，另一线程2锁定B，注意由于这是两个实例的mutex，所以线程B是可以锁定B的。于是死锁。
解决：std::lock可以同时锁定多个互斥元，并且不会造成死锁。std::lock提供原子语义，要么全部锁定，要么全部不锁("全有或全无")。例如std::lock(m1,m2); 如果先锁定了m1，而无法锁定m2，或者锁定m2时抛出了异常，那么异常会传播出std::lock，此时std::lock会将之前的锁定释放掉。

原因2：两个线程相互等待。例如两个线程相互join对方。

死锁避免：
	死锁避免原则都可以归结为：“如果一个线程在等你，你就别等它”。
(1) 避免嵌套锁：
	如果你持有1个锁，就不要再获取其他锁。
	这样每个线程仅仅有一个锁，所以仅凭使用锁，是不会造成死锁的。
	如果需要获取多个锁，就用std::lock. 
	问题：例如线程相互等待，依然会死锁。
(2) 在持有锁时，避免调用用户提供的代码：
	因为代码是用户提供的，你不知道它会干什么。
(3) 以固定的顺序获取锁：
	如果需要获取多个锁，但是需要分别获得（这时候不能调用std::lock），那么次优做法是以固定的顺序获得锁。
(4) 使用锁层次：
	当试图锁定一个互斥元时，如果它在低层已经持有锁，那就不允许它锁定高层次的互斥元。
(5) 将这些设计准则扩展到锁之外：
	死锁不仅仅发生在锁定中，例如循环等待会导致死锁现象，也应该同理设计。


双检锁会带来数据竞争，可能一个线程可以看到另一个线程的指针，却看不到新创建的对象？
https://blog.csdn.net/wpb92/article/details/76714329
解决：内存屏障violate，std::once_flag和std::call_once